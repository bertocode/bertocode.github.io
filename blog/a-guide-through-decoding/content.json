{"is404":false,"staticData":{"1060758163":"{\"parsedFrontmatter\":{\"title\":\"A guide through decoding in Elm\",\"tags\":[\"decoders\",\"elm\",\"guide\"]},\"withoutFrontmatter\":\"\\nDecoding is probably one of the trickiest part of Elm Language, where most people normally struggle for a while and a very important part of the Elm knowledge that sometimes is difficult to understand/lear.\\n\\nI've tried to gather in this document what I believe are the most common situations that can happen while decoding any JSON structure, explained with examples, to help the reader understand them better and help them in the process of building the different decoders into their own structures within Elm.\\n\\n## What's a decoder?\\n\\n_This initial part is partially extracted from [JSON Effects in Elm Guide](https://guide.elm-lang.org/effects/json.html) where decoders are really well explained._\\n\\nWhen we are writing any language (ruby/javascript/python), and we want to parse a JSON, we do something like:\\n\\n`JSON.parse(json_string)`\\n\\nWhen we do this, have no guarantees about any of the information here. The server can change the names of fields, and the fields may have different types in different situations.\\nIt is a wild world!\\n\\nIn JavaScript, the approach is to just turn JSON into JavaScript objects and hope nothing goes wrong.\\nBut if there is some typo or unexpected data, you get a runtime exception somewhere in your code. Was the code wrong? Was the data wrong? It is time to start digging around to find out!\\n\\nIn Elm, we validate the JSON before it comes into our program. So if the data has an unexpected structure, we learn about it immediately.\\nThere is no way for bad data to sneak through and cause a runtime exception three files over. This is accomplished with JSON decoders.\\n\\nI like thinking of JSON Decoders as blueprints that describe the JSON that is going to be received in your program.\\n\\nLet's keep in mind the following object for now:\\n\\n```JSON\\n{ name: \\\"Tom\\\",\\n  age: 25\\n}\\n```\\n\\n## Simple decoding\\n\\nIf we wanted to extract only the name of the person we could create a decoder with the following shape:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\nnameDecoder : D.Decoder String\\nnameDecoder =\\n\\tD.field \\\"name\\\" D.string\\n```\\n\\n`field` function is telling us that is going to find inside the JSON stucture the key that we tell them as first parameter `name` and then, as second parameter the function that explains which kind of structure needs to decode, in this case `string`.\\n\\nThere are two major facts to understand in this function:\\n- Decoders don't get anything passed as parameter, they are not executed yet, they are only descriptions of the object that we are going to decode, and when executed are doing with the following way:\\n\\t\\t`D.decodeString decoderToBeExecuted jsonString`\\n\\t\\tor\\n\\t\\t`D.decodeValue decoderToBeExecuted jsonValue`\\n- The signature of a Decoder  (in this case `D.Decoder String`)  expresses ultimately which structure we would be decoding into. In this case, `nameDecoder` would return a String when executed as previously explained.\\n\\n## Normal decoding mapings based on records\\n\\nSo now imagine we still want to keep the previous stated structure within the Elm application, then we would like to define the following record in Elm, been this the equivalent of a JSON object in javascript:\\n\\n```Elm\\ntype alias Person =\\n{ name: String\\n, age: Int\\n}\\n```\\n\\nSo now if we were in the previous decoded that we created, it would be nice to do something like:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder\\npersonDecoder =\\n\\tD.field \\\"name\\\" D.string\\n\\tD.field \\\"age\\\" D.int\\n```\\n\\nSince in Elm everything is a function and in here, we are actually executing two different functions, there are some ways to unify these two decoders into one:\\n\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder String\\npersonDecoder =\\n\\tD.map2 Person\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" D.int)\\n```\\n\\nwe can use the map functions up to map9, this is map2, map3, map4... , map9, and in case there was more than 9 items in the record you would need to do something like:\\n\\n```Elm\\npersonWithManyFieldsDecoder : D.Decoder PersonWithManyFields\\npersonWithManyFieldsDecoder =\\n\\tD.succeed PersonWithManyFields\\n        |> D.andThen (\\\\f -> D.map f (field \\\"name\\\" D.string)\\n        |> D.andThen (\\\\f -> D.map f (field \\\"age\\\" D.int))\\n\\t\\t\\n\\t\\t-- many other fields here\\n\\t\\t\\n\\t\\t|> D.andThen (\\\\f -> D.map f (field \\\"some_int\\\" int))\\n        |> D.andThen (\\\\f -> D.map f (field \\\"some_date\\\" date))\\n```\\n\\nSince this is quite verbose and complex there are two alternatives to approach this in a more idiomatic way:\\n\\n- Using the [elm-community/json-extra](https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra#andMap), making the code look something like:\\n\\n```Elm\\nimport JSON.Decoder as D\\nimport JSON.Decoder.Extra as DE\\n\\npersonWithManyFieldsDecoder : D.Decoder PersonWithManyFields\\npersonWithManyFieldsDecoder =\\n\\tD.succeed PersonWithManyFields\\n        |> DE.andMap (field \\\"name\\\" D.string)\\n        |> DE.andMap (field \\\"age\\\" D.int)\\n\\t\\t\\n\\t\\t-- many other fields here\\n\\t\\t\\n\\t\\t|> DE.andMap (field \\\"some_int\\\" int)\\n        |> DE.andMap (field \\\"some_date\\\" date)\\n```\\n\\n- Using the library that we've been using historicaly in the company and another very good library that achieves the same is [NoRedInk/elm-json-decode-pipeline](https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/Json.Decode.Pipeline) and it would look like:\\n\\n```ELm\\nimport JSON.Decoder as D\\nimport JSON.Decode.Pipeline as DP\\n\\npersonWithManyFieldsDecoder : D.Decoder PersonWithManyFields\\npersonWithManyFieldsDecoder =\\n\\tD.succeed Person\\n\\t\\t|> DP.required \\\"name\\\" D.string\\n\\t\\t|> DP.required \\\"age\\\" D.int\\n\\t\\t\\n\\t\\t-- many other fields here\\n\\t\\t\\n\\t\\t|> DP.required (field \\\"some_int\\\" int)\\n        |> DP.required (field \\\"some_date\\\" date)\\n```\\n\\n## Decoding Null values\\n\\nLet's think about a particular situation.\\nThere might times where some of this information sometimes doesn't exist, sometimes the information is incomplete or it is not required to actually model the whole data.\\n\\nThis has been normally represented in many languages as the concept of [null. Here its creator talks about this more profoundly](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)\\n\\nOne of the tradeoffs of using null, is that we can let code that shouldn't be executing go through, and evaluating expressions as if there was something, but in reality it isn't.\\n\\nIn Elm the possibility of absence of a value can be modeled as a [Maybe value instead.](https://guide.elm-lang.org/error_handling/maybe.html) Avoiding the possibility of null values go through, enforcing to cover both cases everytime you deal with a Maybe structure.\\n\\nKeeping the previous example before, imagine that we have the following structure:\\n\\n```Elm\\ntype alias Person =\\n\\t{ name: String\\n\\t, age: Maybe Int\\n\\t}\\n```\\n\\nBefore all fields were mandatory (there couldn't be a null in our JSON in order to be decoded), but now this has slightly changed.\\nNow our `Person` structure does have a possible value, that might or might not exist when decoding a JSON structure.\\n\\nIf we want to decode this new structure, the decoder will look like:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder String\\npersonDecoder =\\n\\tD.map2 Person\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" (D.nullable D.int))\\n```\\n\\nor with the `NoRedInk/elm-json-decode-pipeline` syntax:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder String\\npersonDecoder =\\n\\tD.succeed Person\\n\\t\\t|> D.required \\\"name\\\" D.string\\n\\t\\t|> D.required \\\"age\\\" (D.nullable D.int)\\n```\\n\\n### Inconsistent structures decoder\\n\\nWith the previous situation in mind, maybe not only the value is inconsistent but also, the key might be too.\\nImagine now the answers can be:\\n\\n```JSON\\n{\\n\\tname: \\\"nameOfAPerson\\\"\\n}\\n-- or\\n{\\n\\tname: \\\"nameOfAPerson\\\",\\n\\tage: 53\\n}\\n-- or even\\n{\\n\\tname: \\\"nameOfAPerson\\\",\\n\\tage: null\\n}\\n\\n```\\n\\nHow do we handle this in Elm?\\nWell let's see now how the decoder is written now:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder String\\npersonDecoder =\\n\\tD.map2 Person\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.maybe (D.field \\\"age\\\" (D.nullable D.int)))\\n\\n```\\n\\nor with the `NoRedInk/elm-json-decode-pipeline` syntax, here the reference to the [docs](https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/Json-Decode-Pipeline#optional):\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonDecoder : D.Decoder String\\npersonDecoder =\\n\\tD.succeed Person\\n\\t\\t|> D.required \\\"name\\\" D.string\\n\\t\\t|> D.optional \\\"age\\\" (D.nullable D.int) Nothing\\n```\\n\\nThis way, we would ensure that no matter the structure of the JSON, you can always represent this structure in Elm. [Here you can see the actual docs of Maybe](https://package.elm-lang.org/packages/elm/core/latest/Maybe) that might be useful to understand all of these better.\\n\\n## Decode Different versions of a JSON\\n\\nAnother situation when decoding, when you have changed your data structure, let's say, initially you had:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\ntype alias Person =\\n\\t{ name : String\\n\\t, age : Maybe Int\\n\\t}\\n\\npersonDecoder : D.Decoder Person\\npersonDecoder =\\n\\tD.map2 Person\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.maybe (D.field \\\"age\\\" (D.nullable D.int)))\\n\\n```\\n\\nand after sometime, the requirements of your API changes in one of the endpoints and now some of the endpoints are serving a new value `address`, this way we can support both endpoints at the same time:\\n\\n```Elm\\n\\ntype alias PersonV2 =\\n\\t{ name : String\\n\\t, age : Maybe Int\\n\\t, address : Maybe String\\n\\t}\\n```\\n\\nto keep the API working, you can do something like:\\n\\n```Elm\\npersonV1Decoder : D.Decoder PersonV2\\npersonV1Decoder =\\n\\tD.map3 PersonV2\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" (D.nullable D.int)\\n\\t\\t(D.null Nothing)\\n\\t\\t\\npersonV2Decoder : D.Decoder PersonV2\\npersonV2Decoder =\\n\\tD.map3 PersonV2\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" (D.nullable D.int))\\n\\t\\t(D.field \\\"address\\\" (D.nullable D.string))\\n\\t\\t\\npersonDecoder : D.Decoder PersonV2\\npersonDecoder =\\n\\tD.oneOf [personV2Decoder, personV1Decoder]\\n\\n```\\n\\nNote: as you could have probably think aready, this could be also be written directly as:\\n\\n```Elm\\npersonDecoder : D.Decoder PersonV2\\npersonDecoder =\\n\\tD.map3 PersonV2\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" (D.nullable D.int)\\n\\t\\t(D.maybe (D.field \\\"address\\\" (D.nullable D.string)))\\n\\t\\n```\\n\\n## Decoding and map into types\\n\\nWhen you are used to work with Elm, there are many times when you want to encapsulate information around types, [here is a good talk about why this is interesting](https://www.youtube.com/watch?v=IcgmSRJHu_8).\\n\\nWhen doing this, it's not so clear how we could implement a decoder.\\nImagine we have the following code:\\n\\n```Elm\\n\\ttype Person \\n\\t\\t= MinorPerson String\\n\\t\\t| AdultPerson String\\n```\\n\\nWe want a `MinorPerson` to represent someone which age is under 18 but an `AdultPerson` would be someone who is over that age integer number.\\n\\nLet's now a create a decoder that cover this case:\\n\\n```ELm\\nimport JSON.Decoder as D\\n\\npersonTypedDecoder : D.Decoder Person\\npersonTypedDecoder =\\n\\tD.field \\\"age\\\" D.int\\n\\t\\t|> D.andThen (\\\\age ->\\n\\t\\t\\tif age < 18 then\\n\\t\\t\\t\\tD.map MinorPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\telse\\n\\t\\t\\t\\tD.map AdultPerson (D.field \\\"name\\\" D.string)\\n\\t\\t)\\n```\\n\\nThis gets a little bit more complex now, what is happening here is that you need to **decode age first** in order to get the information to actually choose between a MinorPerson and an AdultPerson, so we do that by decoding that information first.\\nThen `andThen` function, let us access the information previously decoded, and then let us decode the rest of the object based on that information, in this case `age`.\\n\\nThen, the `map` function, let us build the types as if it was a constructor (which it is), by mapping the decoder of the field `name` into the constructor of Person `MinorPerson` and `AdultPerson`.\\n\\n### Decoding dependant structures with `andThen` within a record\\n\\nThe previous idea can be done at all levels, imagine that `Person` now lives within a record, and not as an isolated entity, let's say now our person is:\\n\\n```Elm\\ntype Person \\n\\t= MinorPerson String\\n\\t| AdultPerson String\\n\\t\\n-- and now we have\\n\\ntype alias PersonInformation =\\n\\t{ person : Person\\n\\t, address : String\\n\\t, identityNumber : String\\n\\t}\\n\\n```\\n\\nand the JSON coming from the backend it is something like:\\n\\n```JSON\\n{\\n\\tname: \\\"NameOfThePerson\\\",\\n\\tage: 32,\\n\\taddress: \\\"AddressOfThePerson\\\",\\n\\tid_number: \\\"54323J\\\"\\n}\\n```\\n\\nIf we were to build now the decoder, it would have the following shape (to simplify mapping, I will use `NoRedInk/elm-json-decode-pipeline`):\\n\\n```Elm\\npersonInformationDecoder : D.Decoder PersonInformation\\npersonInformationDecoder =\\n\\tD.succeed PersonInformation\\n\\t\\t|> D.required \\\"age\\\"\\n\\t\\t\\t(D.String \\n\\t\\t\\t\\t|> D.andThen (\\\\age ->\\n\\t\\t\\t\\t\\tif age < 18 then\\n\\t\\t\\t\\t\\t\\tD.map MinorPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tD.map AdultPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t)\\n\\t\\t|> D.required \\\"adress\\\" D.string\\n\\t\\t|> D.required \\\"id_number\\\" D.string\\n\\n```\\n\\n## Decoding lists\\nNormally when modelling any of these decoders, it is likely that we are not only decoding one element. Normally we are decoding multiple elements into a different structure.\\n\\nThe most common structure possibly is a list of these elements, let's go through how it would be to become any previous decoder into a `D.Decoder List something`\\n\\nUsing the previous `personInformationDecoder`:\\n\\nIf we would like decode a list of these elements we could create the decoder the following way:\\n\\n```Elm\\npersonInformationListDecoder : D.Decoder (List PersonInformation)\\npersonInformationListDecoder =\\n\\t(D.succeed PersonInformation\\n\\t\\t|> D.required \\\"age\\\"\\n\\t\\t\\t(D.String \\n\\t\\t\\t\\t|> D.andThen (\\\\age ->\\n\\t\\t\\t\\t\\tif age < 18 then\\n\\t\\t\\t\\t\\t\\tD.map MinorPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tD.map AdultPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t)\\n\\t\\t|> D.required \\\"adress\\\" D.string\\n\\t\\t|> D.required \\\"id_number\\\" D.string)\\n\\t\\t|> D.list\\n```\\n\\nor we we want to reuse the previous function:\\n\\n```Elm\\npersonInformationListDecoder : D.Decoder (List PersonInformation)\\npersonInformationListDecoder =\\n\\tpersonDecoder\\n\\t\\t|> D.list\\n```\\n\\n## Transform a list into a dictonary\\nThere are situations where we don't want to store the information into a list, but maybe as a Dictionary instead, this is because we do not need to keep the order (List maintain order, Dicts don't), but we care about fast access when using the information within the structure.\\n\\nLet's transform the previous decoder, by using the `id_number` which we have previously described as unique (so it can serve us as a key for the `Dict`) into a `D.Decoder Dict PersonInformation`.\\n\\n```Elm\\npersonInformationListDecoder : D.Decoder (List PersonInformation)\\npersonInformationListDecoder =\\n\\t(D.succeed PersonInformation\\n\\t\\t|> D.required \\\"age\\\"\\n\\t\\t\\t(D.String \\n\\t\\t\\t\\t|> D.andThen (\\\\age ->\\n\\t\\t\\t\\t\\tif age < 18 then\\n\\t\\t\\t\\t\\t\\tD.map MinorPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tD.map AdultPerson (D.field \\\"name\\\" D.string)\\n\\t\\t\\t)\\n\\t\\t|> D.required \\\"adress\\\" D.string\\n\\t\\t|> D.required \\\"id_number\\\" D.string)\\n\\t\\t|> D.list\\n\\n\\t\\t--- Same decoder as before but know we need to make it a dictionary\\n\\n\\t\\t|> D.andThen(\\\\people ->\\n\\t\\t\\tpeople\\n\\t\\t\\t\\t|> List.map (\\\\person -> (person.identityNumber, person))\\n\\t\\t\\t\\t|> Dict.fromList\\n\\t\\t\\t\\t|> D.succeed\\n\\t\\t)\\n```\\n\\n## Decoding key-value objects\\n\\nWe just saw how it is to decode a list of elements, or how we can get the values and then map it into a Dict. Other times, maybe, the structure is already served within a JSON object, like this:\\n\\n```JSON\\n{\\n\\t\\\"54323J\\\": {\\n\\t\\tname: \\\"NameOfThePerson\\\",\\n\\t\\tage: 32,\\n\\t\\taddress: \\\"AddressOfThePerson\\\",\\n\\t},\\n\\t\\\"53212Y\\\" : {\\n\\t\\tname: \\\"NameOfAnotherPerson\\\",\\n\\t\\tage: 12,\\n\\t\\taddress: \\\"AddressOfAnotherPerson\\\",\\n\\t},\\n}\\n```\\n\\nWe assume here, like in the previous example, that the id number of this person (a  unequivocally distinctive value) is the key of our json and we can map it into a dictionary the following way:\\n\\n```Elm\\nimport JSON.Decoder as D\\n\\ntype alias Person =\\n\\t{ name : String\\n\\t, age : Int\\n\\t, address : String\\n\\t}\\n```\\n\\n```Elm\\npersonTypedDecoder : D.Decoder (Dict String Person)\\npersonTypedDecoder =\\n\\tD.keyValuePairs\\n\\t\\t(D.map3 Person\\n\\t\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t\\t(D.field \\\"age\\\" D.int)\\n\\t\\t\\t(D.field \\\"address\\\" D.string))\\n```\\n\\n\\n## Decoding dependant structures based on the key of a key-value object (how the list decoding works)\\n\\nWe found in the previous example how easy is to decode a structure like `{id: value}` in Elm, but what would it happen if the value is dependant to the id?\\n\\nImagine that we previously have some data about the people based on the id and in order to decode the `personInformation`, we need to access that data to do the decoding. To do this, we can avoid decoding in the first place, by using the decoder [D.value](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#value) keeping the dictionary data as a JSON still without decoding it, and then when we have the information, from the `id` in a second step, decode the [JSON Value](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#value) (anchor in the page doesn't correctly work, scroll to `type Value`).\\n\\nNow as before with the same data shape:\\n\\n```JSON\\n{\\n\\t\\\"54323J\\\": {\\n\\t\\tname: \\\"NameOfThePerson\\\",\\n\\t\\tage: 32,\\n\\t\\taddress: \\\"AddressOfThePerson\\\",\\n\\t},\\n\\t\\\"53212Y\\\" : {\\n\\t\\tname: \\\"NameOfAnotherPerson\\\",\\n\\t\\tage: 12,\\n\\t\\taddress: \\\"AddressOfAnotherPerson\\\",\\n\\t},\\n}\\n```\\n\\nImagine we want to the code something with the shape of:\\n\\n```Elm\\nimport JSON.Decoder as D\\n\\ntype alias PersonId = String\\n\\ntype alias Person =\\n\\t{ name : String\\n\\t, age : Int\\n\\t, address : String\\n\\t, otherData : OtherData\\n\\t}\\n\\t\\n--- and we have in our model\\n--- { otherDataDict : Dict PersonId OtherData }\\n```\\n\\nThen we can structure our decoder the following way, now we pass the dict where we store the data about the people to the decoder to be able to use it in the decoding process:\\n\\n```Elm\\npersonDictDecoder : Dict PersonId OtherData -> D.Decoder (Dict PersonId Person)\\npersonDictDecoder otherDataDict =\\n\\tD.keyValuePairs D.value\\n\\t\\n\\t\\t-- we decode the ids first and then\\n\\t\\t\\n\\t\\t|> D.andThen (\\\\listOfPeopleIds-> \\n\\t\\t\\tList.filterMap (\\\\(personId, personValue) -> \\n\\t\\t\\t\\tcase Dict.get personId otherDataDict of\\n\\t\\t\\t\\t\\tJust personData ->\\n\\t\\t\\t\\t\\t\\tcase D.decodeValue (personDecoder personData) personValue of\\n\\t\\t\\t\\t\\t\\t\\tOk decodedPerson ->\\n\\t\\t\\t\\t\\t\\t\\t\\tJust (id, decodedPerson) \\n\\t\\t\\t\\t\\t\\t\\tErr _ ->\\n\\t\\t\\t\\t\\t\\t\\t\\tNothing \\n\\t\\t\\t\\t\\tNothing -> Nothing ) listOfPeopleIds \\n\\t\\t\\t|> D.succeed\\n\\t\\t)\\n```\\n\\nwhere `personDecoder` is:\\n\\n```Elm\\n\\npersonDecoder : OtherData -> D.Decoder Person\\npersonDecoder otherData =\\n\\tD.map4 Person\\n\\t\\t(D.field \\\"name\\\" D.string)\\n\\t\\t(D.field \\\"age\\\" D.int)\\n\\t\\t(D.field \\\"address\\\" D.string)\\n\\t\\t(D.succeed otherData)\\n```\\n\\n\\n### Note: Making decoder actually aware of the error\\n\\nSometimes there are some errors happening within the inner decoder in D.decodeValue, since we are doing a `filterMap` in the previous decoding, we are removing all the errors from the decoding steps.\\n\\nA possibility (although might not be the best) to keep the error either from the `Dict PersonId OtherData` when doing the Dict.get, i.e. there is no information about that person in the Dict or from the `D.decodeValue (personDecoder personData) personValue` can be, to keep the `Maybe`s withing the array by using a map instead and then if any `Nothing` is still in the list, that means there was some of the branches that couldn't succeed, and we can raise an error for the integrity of the decoded data this way:\\n\\n```Elm\\npersonDictDecoder : Dict PersonId OtherData -> D.Decoder (Dict PersonId Person)\\npersonDictDecoder otherDataDict =\\n\\tD.keyValuePairs D.value\\n\\t\\n\\t\\t-- we decode the ids first and then\\n\\t\\t\\n\\t\\t|> D.andThen (\\\\listOfPeopleIds->\\n\\t\\t\\tlet\\n\\t\\t\\t\\tlistOfDecodedPeople = \\n\\t\\t\\t\\t\\tList.map (\\\\(personId, personValue) -> \\n\\t\\t\\t\\t\\t\\tcase Dict.get personId otherDataDict of\\n\\t\\t\\t\\t\\t\\t\\tJust personData ->\\n\\t\\t\\t\\t\\t\\t\\t\\tcase D.decodeValue (personDecoder personData) personValue of\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tOk decodedPerson ->\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tJust (id, decodedPerson) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tErr _ ->\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNothing \\n\\t\\t\\t\\t\\t\\t\\tNothing -> Nothing ) listOfPeopleIds \\n\\t\\t\\tin\\n\\t\\t\\tif List.any (\\\\person -> person == Nothing) listOfDecodedPeople then\\n\\t\\t\\t \\tD.fail \\\"There was some error decoding the people\\\"  \\n\\t\\t\\t else  \\n\\t\\t\\t \\tlistOfDecodedPeople\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t-- we remove the maybes with this map\\n\\n\\t\\t\\t\\t\\t|> List.filterMap identity  \\n\\t\\t\\t\\t\\t|> D.succeed  \\n\\t\\t)\\n```\\n\\n\"}"},"path":"blog/a-guide-through-decoding"}